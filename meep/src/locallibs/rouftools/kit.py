
from typing import List, Dict, Tuple, Any, Callable, Optional, Iterator, AsyncIterator
import pydantic, asyncio, inspect

from .tool import BaseTool, ToolMessage, ToolCall

def create_model(name: str, signature: inspect.Signature) -> pydantic.BaseModel:
    """Create a Pydantic model from a function signature."""
    fields: Dict[str, Tuple[type, ellipsis]] = {}
    for param in signature.parameters.values():
        if param.kind in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD):
            continue  # Skip *args and **kwargs
        if param.annotation is inspect.Parameter.empty:
            raise ValueError(f"Parameter {param.name} has no type annotation")
        default = ... if param.default is inspect.Parameter.empty else param.default
        fields[param.name] = (param.annotation, default)
    return pydantic.create_model(name, **fields) if fields else None

def build_tool_payload(inp: Optional[pydantic.BaseModel] = None, extra_kwargs: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    if inp:
        payload = {**inp.model_dump(), **extra_kwargs} if extra_kwargs else inp.model_dump()
    else:
        payload = extra_kwargs if extra_kwargs else {}
    return payload

class ToolKit(pydantic.BaseModel):
    """
    A collection of tools for a LLM.
    """
    tools: Dict[str, BaseTool] = {}
    
    def __getitem__(self, key: str, default: Any = None) -> BaseTool:
        return self.tools.get(key, default)

    def __setitem__(self, key: str, value: BaseTool) -> None:
        self.tools[key] = value
        
    def __in__(self, reference: BaseTool) -> bool:
        return reference in self.tools.values()
    
    def __iter__(self):
        return iter(self.tools.values())
    
    def __call__(self, calls: List[ToolCall], *, extra_kwargs: Optional[Dict[str, Any]] = None) -> List[ToolMessage]:
        return self.run(calls, extra_kwargs=extra_kwargs)

    def run(self, calls: List[ToolCall], *, extra_kwargs: Optional[Dict[str, Any]] = None) -> List[ToolMessage]:
        return [self.tools[call["name"]].run(call, extra_kwargs=extra_kwargs) for call in calls]

    async def arun(self, calls: List[ToolCall], *, extra_kwargs: Optional[Dict[str, Any]] = None) -> List[ToolMessage]:
        results = await asyncio.gather(
            *[self.tools[call["name"]].arun(call, extra_kwargs=extra_kwargs) for call in calls]
        )
        return results
        
    def tool(self, f: Callable) -> BaseTool:
        """
        Decorator to convert a function into a BaseTool instance and **bind** it to the current ToolKit.
        The tool can be extracted from the ToolKit by calling get.

        The decorated function can be synchronous, asynchronous, or a generator.
        When using generators, each yielded value produces a streamed event, and the final value
        is displayed to the LLM. Raises ValueError if the function signature is invalid.
        
        A tool can accept **kwargs to receive extra_kwargs (global context) when invoked.
        They can return a Tuple[response, artifact (dict)] to provide an additional artifact 
        that will not be part of the final response.

        ## Example:
        
            @tool
            def func(inp: InputModel, **kwargs):
                return f"The input was {inp.parameter}", {"additional_info": f"some_value {kwargs['info']}"}
        """
        # Inspect the function signature to ensure it has zero or one parameter.
        sig = inspect.signature(f)
        if sig.parameters:
            input_model = create_model(f.__name__, sig)
        else:
            input_model = None
        
        # Determine the function type (sync/async, generator, etc.)
        is_async = asyncio.iscoroutinefunction(f)
        is_gen = inspect.isgeneratorfunction(f)
        is_asyncgen = inspect.isasyncgenfunction(f)
        
        # Detect **kwargs
        has_kwargs = any(p.kind is inspect.Parameter.VAR_KEYWORD for p in sig.parameters.values())
        
        # Dynamically create a BaseTool subclass that wraps f.
        class ToolWrapper(BaseTool):
            name: str = f.__name__
            description: str = f.__doc__ or (
                f"This tool was autogenerated by a decorated function. No docstring was included "
                f"in the original function, therefore this tool has no description. Please warn the developer "
                f"that function \"{f.__name__}\" needs a docstring."
            )
            args_schema: Optional[type] = input_model
            accept_kwargs: bool = has_kwargs
            
            if is_asyncgen:
                async def _astream(self, inp: Optional[pydantic.BaseModel] = None, extra_kwargs: Optional[Dict[str, Any]] = None) -> AsyncIterator[str]:
                    if not self.accept_kwargs: extra_kwargs = None
                    stream = f(**build_tool_payload(inp, extra_kwargs))
                    async for item in stream:
                        yield item

            elif is_gen:
                def _stream(self, inp: Optional[pydantic.BaseModel] = None, extra_kwargs: Optional[Dict[str, Any]] = None) -> Iterator[str]:
                    if not self.accept_kwargs: extra_kwargs = None
                    stream = f(**build_tool_payload(inp, extra_kwargs))
                    for item in stream:
                        yield item

            elif is_async:
                async def _arun(self, inp: Optional[pydantic.BaseModel] = None, extra_kwargs: Optional[Dict[str, Any]] = None) -> str:
                    if not self.accept_kwargs: extra_kwargs = None
                    coro = f(**build_tool_payload(inp, extra_kwargs))
                    result = await coro
                    return result

            else:
                def _run(self, inp: Optional[pydantic.BaseModel] = None, extra_kwargs: Optional[Dict[str, Any]] = None) -> str:
                    if not self.accept_kwargs: extra_kwargs = None
                    result = f(**build_tool_payload(inp, extra_kwargs))
                    return result
        
        # Bind to tool kit and return as a BaseTool instance.
        self.tools[f.__name__] = ToolWrapper()
        
        return self.tools[f.__name__]
